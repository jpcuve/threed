<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/AssetLoader.js"></script>
<script src="js/Spindizzy.js"></script>


<div style="position: relative; width: 500px; height: 500px;">
    <canvas id="canvas" style="position: relative; width: 100%; height: 100%;"></canvas>
    <div id="hud" style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 1000; color: red;">
        <span id="screenPosition"/>
    </div>
</div>

<script>

    function Board(){
        var x, y, z;
        // each column contains type & rotation, starting from height 0
        this.columns = [
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []]
        ];
        this.helpGeometry = new THREE.Geometry();
        this.boardGeometry = new THREE.Geometry();
        for (x = 0; x <= 8; x++){
            for (y = 0; y <= 8; y++){
                for (z = 0; z <= 8; z++){
                    this.helpGeometry.vertices.push(new THREE.Vector3(x, y, z * 0.5));
                    this.boardGeometry.vertices.push(new THREE.Vector3(x, y, z * 0.5));
                }
            }
        }
    }

    Board.prototype.vertexAt = function(x, y, z){
        return x * 81 + y * 9 + z;
    };

    Board.contours = {
        none: {
            height: [0, 0, 0, 0]
        },
        basic: {
            height: [1, 1, 1, 1]
        },
        gentleSlope: {
            height: [0, 0, 1, 1]
        },
        normalSlope: {
            height: [0, 0, 2, 2]
        },
        hardSlope: {
            height: [0, 0, 3, 3]
        }
    };

    Board.tops = {
        plain: {

        },
        trampoline: {

        },
        water: {

        },
        ice: {

        },
        arrow: {

        }
    };

    Board.prototype.play = function(layout, p, r, nature, type){
        "use strict";
        var column = this.columns[p.x][p.y], z, h;
        switch(layout){
            case 'basic':
                h = p.z;
                break;
            case 'column':
                for (h = 0; h < p.z; h++){
                    column[h] = {contour: Board.contours.basic};
                }
                break;
            case 'extrude':
                    // do not know what to do
                break;
            case 'special':
                    // later
                break;
        }
        switch(nature){
            case 'block':
                column[h] = {contour: Board.contours.basic, top: Board.tops.plain};
                break;
            case 'trampoline':
                column[h] = {contour: Board.contours.basic, top: Board.tops.trampoline};
                break;
            case 'water':
                column[h] = {contour: Board.contours.basic, top: Board.tops.water};
                break;
            case 'ice':
                column[h] = {contour: Board.contours.basic, top: Board.tops.ice};
                break;
            case 'arrow':
                column[h] = {contour: Board.contours.basic, top: Board.tops.arrow, rotation: r % 4};
                break;
            case 'slope':
                column[h] = {contour: Board.contours.hardSlope, top: Board.tops.arrow, rotation: r % 4};
                break;
        }
    };

    Board.prototype.compute = function(){
        this.boardGeometry.faces = [];
        this.boardGeometry.faces.push(new THREE.Face3(0, 245, 612));
    };

    var board = new Board();


    function paint(layout, p, r, nature, type){
        "use strict";
        board.play(layout, p, r, nature, type);
        console.log('*', layout,'(', p.x, ',', p.y, ',', p.z, ')r:', r, nature, type);
        /*
        var geometry = piece.basicBlock();
        switch(layout){
            case 'column':
                geometry = piece.basicBlock(p.z);
                break;
        }
        var color = 'red';
        switch(nature){
            case 'block':
                color = 'white';
                break;
            case 'slope':
                    switch(type){
                        case 1:
//                            piece.simpleSlope(0);
                            break;
                        case 2:
//                            piece.simpleSlope(1);
                            break;
                        case 5:
//                            piece.convexSlope1(0);
                            break;
                        case 6:
//                            piece.concaveSlope1(0);
                            break;
                        case 7:
//                            piece.concaveSlope2(0);
                            break;

                    }
                    console.log("TYPE:", type);
                    if (type <= 2){
//                        piece.simpleSlope(type);
                    } else if (type <= 4){
                    } else if (type <= 6){
//                        piece.concaveSlope1(1);
                    } else {
//                        piece.concaveSlope2(1);
                    }
                    color = 'white';
                break;
            case 'arrow':
                color = 'green';
                break;
            case 'trampoline':
                color = 'yellow';
                break;
            case 'water':
                color = 'blue';
//                piece.addZ(-1);
                break;
        }
        var darkMaterial = new THREE.MeshBasicMaterial( { color: color } );
       	var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );
       	var multiMaterial = [ darkMaterial, wireframeMaterial ];
        var boxMesh = THREE.SceneUtils.createMultiMaterialObject(geometry, multiMaterial);
        boxMesh.translateX(p.x - 3.5);
        boxMesh.translateY(3.5 - p.y);
        boxMesh.translateZ(p.z / 2);
        boxMesh.rotateZ(-(r % 4) * Math.PI / 2);
        scene.add(boxMesh);
*/
    }

    var i = 64, j = 64, player;
    var assetLoader = new AssetLoader(function(assets) {
        "use strict";
        player = new Player(assets['brushes'].asset, assets['screens'].asset);
        update();
    });
    assetLoader.add('brushes', 'binary', 'assets/models/spindizzy_brushes.bin');
    assetLoader.add('screens', 'binary', 'assets/models/spindizzy_screens.bin');
    assetLoader.load();


    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var orbitControls = new THREE.OrbitControls(camera);

    var canvas = document.getElementById('canvas');
    var renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);


    camera.position.z = 10;

    var scene = new THREE.Scene();

    document.onkeypress = function(evt) {
        evt = evt || window.event;
        var charCode = evt.keyCode || evt.which;
        var charStr = String.fromCharCode(charCode);
        switch(charStr){
            case 'q':
                i = (i - 1) & 0x7F;
                break;
            case 'd':
                i = (i + 1) & 0x7F;
                break;
            case 'z':
                j = (j - 1) & 0x7F;
                break;
            case 's':
                j = (j + 1) & 0x7F;
                break;
        }
        update();
    };

    function update(){
        scene = new THREE.Scene();
        var plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(8, 8, 8, 8), new THREE.MeshBasicMaterial({ wireframe: false, color: 'lightgray', transparent: true, opacity: 0.8 }));
//        scene.add(plane);
        player.screen(paint, new THREE.Vector2(i, j), 0);
        scene.add(new THREE.Points(board.helpGeometry, new THREE.PointsMaterial({size: 0.1})));
        board.compute();
        var boardMesh = new THREE.Mesh(board.boardGeometry, new THREE.MeshBasicMaterial({color: 0x888888}));
        scene.add(boardMesh);
        document.getElementById('screenPosition').innerHTML = 'screen: ' + i + ',' + j; // problem at 61,56
        requestAnimationFrame(animate);
    }

    var animate = function (){
        "use strict";
        orbitControls.update();
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    };

</script>

</body>
</html>