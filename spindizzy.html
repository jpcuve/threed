<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/AssetLoader.js"></script>
<script>
    function Player(brushData, screenData){
        this.brushes = {};
        this.screens = {};
        this.methods = ['basic', 'extruded', 'basic', 'column', 'special'];
        var brushCount = 0, screenCount = 0, offset, l, i, j;
        offset = 0;
        while (offset < brushData.length){
            l = brushData[offset + 1];
            this.brushes[brushData[offset]] = brushData.slice(offset, offset + l);
            offset += l;
            brushCount++;
        }
        console.log('brush count:', brushCount);
        offset = 0;
        while (offset < screenData.length){
            l = screenData[offset];
            j = screenData[offset + 1];
            i = screenData[offset + 2];
            if ((i & 0x80) !== 0){
                i -= 0x80;
                this.start = new THREE.Vector2(i, j);
            }
            this.screens[(j << 8) + i] = screenData.slice(offset, offset + l);
            offset += l;
            screenCount++;
        }
        console.log('screen count:', screenCount);
    }

    Player.prototype.rotate = function(p, r){
        var v;
        switch(r % 3){
            case 1:
                v = 7 - p.y;
                p.set(v, p.x);
                break;
            case 2:
                v = 7 - p.x;
                p.set(v, 7 - p.y);
                break;
            case 3:
                v = p.y;
                p.set(v, 7 - p.x);
                break;
        }
    };

    Player.prototype.terrain2 = function(level, paint, po, ro, buffer, offset){
        var l, p, i;
        while ((l = buffer[offset] + (buffer[offset + 1] << 8)) != 0){
            p = new THREE.Vector3(l >> 10 & 7, l >> 13 & 7, l >> 7 & 7);
//            console.log('local position: (', p.x, ',', p.y, ',', p.z, ')');
            p.add(po);
            // apply rotation
/*
            for (i = 0; i < ro; i++){
                var xp = 7 - p.y;
                p.setY(p.x);
                p.setX(xp);
            }
*/
            this.rotate(p, ro);
            var f = l & 0x7F, m = f >> 5, t = f >> 2 & 7, r = 0, nature = 'undefined', type = 0;
            if ((f & 0x1F) === 2) {
                var index = buffer[offset + 2], brush = this.brushes[index];
                if (index == 25){
                    console.log('check');
                }
                r = (l >> 5) & 3;
                console.log(level + 1, '> brush:', index, ', local rotation:', r);
                this.terrain2(level + 1, paint, p, ro + r, brush, 2);
                console.log(level + 1, '> end brush:', index);
                offset++;
            } else {
                switch(f){
                    case 1:
                    case 0x21:
                    case 0x61:
                        nature = 'square';
                        break;
                    case 3:
                    case 0x23:
                    case 0x63:
                        nature = 'trampoline';
                        break;
                    case 0x20:
                        nature = 'water';
                        break;
                    case 0x43:
                        nature = 'ice';
                        break;
                    default:
                        if ((f & 0x50) === 0x50){
                            nature = 'clue';
                            type = f & 0xF;
                        } else if ((f & 0x44) === 0x44){
                            nature = 'arrow';
                            r = f & 3;
                        } else {
                            nature = 'block';
                            type = t;
                            r = f & 3;
                        }
                        break;
                }
                paint(this.methods[m], p, ro + r, nature, type);
            }
            offset += 2;
        }
        return offset + 2;
    };

    Player.prototype.brush = function(level, paint, x, y, z, r, index){
        console.log(level,'> brush:', index);
        var brush = this.brushes[index], offset;
        if (brush){
            if (index === 29){
                console.log('index is 29');
            }
            offset = 2;
            while (offset < brush.length - 2){
                offset += this.terrain(level, paint, x, y, z, r, brush, offset);
            }
        }
        console.log(level, '> end brush:', index);
    };

    Player.prototype.screen = function(paint, p){
        var screen = this.screens[(p.y << 8) + p.x], offset;
        if (screen) {
            console.log('0 > screen:', p.x, p.y);
            var l = screen[4] + screen[5] << 8;
//            var p = new THREE.Vector3(l >> 10 & 7, l >> 13 & 7, l >> 7 & 7);
            // TODO process floor, using x and y
            offset = this.terrain2(0, paint, new THREE.Vector3(), 0, screen, 6);
/*
            offset = 6;
            while (!(screen[offset] == 0 && screen[offset + 1] == 0)){
                offset += this.terrain(level, paint, new THREE.Vector3(), 0, screen, offset);
            }
            offset += 2;
*/
            while(offset < screen.length - 2){
                offset += this.special(paint, new THREE.Vector3(), 0, screen, offset);
            }
            console.log('0 > end screen:', p.x, p.y);
            return true;
        }
        return false;
    };

    Player.prototype.special = function(paint, po, ro, buffer, offset){
        var l = buffer[offset] + (buffer[offset + 1] << 8) + (buffer[offset + 2] << 16);
        var p = new THREE.Vector3(l >> 10 & 7, l >> 13 & 7, l >> 7 & 7);
        var nature = 'undefined';
        if ((l & 0x7F) === 1){
            nature = 'jewel';
        } else if ((l & 0x7) === 2){
            nature = 'lift';
        } else if ((l & 0x77) === 3){
            nature = 'enemy';
        } else if ((l & 4) === 4){
            nature = 'puzzle';
        }
        paint(this.methods[4], new THREE.Vector3().addVectors(po, p), ro, nature, l);
        return 3;
    };

    Player.prototype.terrain = function(level, paint, po, ro, buffer, offset){
        var l = buffer[offset] + (buffer[offset + 1] << 8);
        var p = new THREE.Vector3(l >> 10 & 7, l >> 13 & 7, l >> 7 & 7);
        if ((l & 0x1F) === 2){ // brush reference
            this.brush(level + 1, paint, xo + x, yo + y, zo + z, (ro + r) & 3, buffer[offset + 2]);
            return 3;
        }
        var f = l & 0x7F, m = f >> 5, t = f >> 2 & 7, nature = 'undefined', type = 0;
        switch(f){
            case 1:
            case 0x21:
            case 0x61:
                nature = 'square';
                break;
            case 3:
            case 0x23:
            case 0x63:
                nature = 'trampoline';
                break;
            case 0x20:
                nature = 'water';
                break;
            case 0x43:
                nature = 'ice';
                break;
            default:
                if ((f & 0x50) === 0x50){
                    nature = 'clue';
                    type = f & 0xF;
                } else if ((f & 0x44) === 0x44){
                    nature = 'arrow';
                } else {
                    nature = 'block';
                    type = t;
                }
                break;
        }
        paint(this.methods[m], new THREE.Vector3().addVectors(po, p), ro + r, nature, type);
        return 2;
    };

    function paint(method, p, r, nature, type){
        console.log(method,'(', p.x, ',', p.y, ',', p.z, ')', r, nature, type);
    }

    var assetLoader = new AssetLoader(function(assets) {
        var player = new Player(assets['brushes'].asset, assets['screens'].asset);
        player.screen(paint, player.start);
/*
        var x, y, ar;
        for (y = 40; y < 80; y++){
            if (y % 10 == 0){
                console.log("-");
            }
            ar = [];
            for (x = 40; x < 90; x++) {
                if (x % 10 == 0) {
                    ar.push(" ");
                }
                if (player.screen(paint, x, y)) {
                    ar.push("*");
                } else {
                    ar.push(".");
                }
            }
            console.log(ar.join(""));
        }
*/
    });
    assetLoader.add('brushes', 'binary', 'assets/models/spindizzy_brushes.bin');
    assetLoader.add('screens', 'binary', 'assets/models/spindizzy_screens.bin');
    assetLoader.load();

    var scene = new THREE.Scene();
    var plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(8, 8, 8, 8), new THREE.MeshBasicMaterial({ wireframe: true }));
    scene.add(plane);

    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var orbitControls = new THREE.OrbitControls(camera);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var geometry = new THREE.BoxGeometry(1, 1, 1);
    var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    var cube = new THREE.Mesh(geometry, material);
//    scene.add(cube);

    camera.position.z = 10;

    var animate = function (){
        orbitControls.update();
        requestAnimationFrame(animate);
        cube.rotation.x += 0.1;
        cube.rotation.y += 0.1;
        renderer.render(scene, camera);
    };

</script>



</body>
</html>