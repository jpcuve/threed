<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/AssetLoader.js"></script>
<script src="js/Spindizzy.js"></script>


<div style="position: relative; width: 500px; height: 500px;">
    <canvas id="canvas" style="position: relative; width: 100%; height: 100%;"></canvas>
    <div id="hud" style="position: absolute; left: 0; top: 0; width: 100%; height: 100%; z-index: 1000; color: red;">
        <span id="screenPosition"/>
    </div>
</div>

<script>

    function Piece(){
        this.debug = true;
        this.vertices = [
            // top face
            [0.5, 0.5, 0.25],       //0
            [-0.5, 0.5, 0.25],      //1
            [-0.5, -0.5, 0.25],     //2
            [0.5, -0.5, 0.25],      //3
            // bottom face
            [0.5, 0.5, -0.25],      //4
            [-0.5, 0.5, -0.25],     //5
            [-0.5, -0.5, -0.25],    //6
            [0.5, -0.5, -0.25]      //7
        ];
        this.faces = [
            [0, 4, 5], [5, 1, 0],
            [1, 5, 6], [6, 2, 1],
            [2, 6, 7], [7, 3, 2],
            [3, 7, 4], [4, 0, 3]
        ];
        this.top1 = [
            [0, 1, 2], [2, 3, 0]
        ];
        this.top2 = [
            [1, 2, 3], [3, 0, 1]
        ]
    }

    Piece.prototype.basicBlock = function(height){
        var geometry = new THREE.BufferGeometry(), i, j, h = height || 1, vs = new Float32Array(this.vertices.length * 3), cs = new Float32Array(this.vertices.length * 3), fs = new Uint32Array((this.faces.length + this.top1.length) * 3);
        for (i = 0; i < this.vertices.length; i++){
            vs[i * 3] = this.vertices[i][0];
            vs[i * 3 + 1] = this.vertices[i][1];
            vs[i * 3 + 2] = this.vertices[i][2];
            cs[i * 3] = 0.5;
            cs[i * 3 + 1] = 0.5;
            cs[i * 3 + 2] = 0.5;
        }
        for (i = 0; i < 4; i++){
            vs[i * 3 + 2] *= h;
        }
        geometry.addAttribute('position', new THREE.BufferAttribute(vs, 3));
        geometry.addAttribute('color', new THREE.BufferAttribute(cs, 3));
        for (i = 0; i < this.faces.length; i++){
            j = i * 3;
            fs[j] = this.faces[i][0];
            fs[j + 1] = this.faces[i][1];
            fs[j + 2] = this.faces[i][2];
        }
        var top = this.top1;
        for (i = 0; i < top.length; i++){
            j = (this.faces.length + i) * 3;
            fs[j] = top[i][0];
            fs[j + 1] = top[i][1];
            fs[j + 2] = top[i][2];
        }
        geometry.setIndex(new THREE.BufferAttribute(fs, 1));
        return geometry;
    };

    var piece = new Piece();

    function Board(){
        this.columns = [
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []],
            [[], [], [],[], [], [], [], []]
        ];
    }

    Board.prototype.play = function(layout, p, r, nature, type){
        "use strict";
        var column = this.columns[p.x][p.y], z, h;
        switch(layout){
            case 'column':
            case 'extrude':
                z = 0;
                h = p.z;
                break;
            default:
                z = p.z;
                h = 0;
                break;
        }
        column.push({z: z, h: h, r: r, nature: nature, type: type});
    };

    Board.prototype.processColumn = function(x, y){
        "use strict";
        var column = this.columns[x][y], busy = [], i;
        // phase 1: only keep pieces that do not overlap (busy contains the indexes of the pieces in each column that must be displayed)

        // phase 2: merge contiguous blocks
        // phase 3: return array of blocks as objects with z-low, z-hi, type, rotation (that must be post processed)

    };

    var board = new Board();


    function paint(layout, p, r, nature, type){
        "use strict";
        board.play(layout, p, r, nature, type);
        console.log('*', layout,'(', p.x, ',', p.y, ',', p.z, ')r:', r, nature, type);
        var geometry = piece.basicBlock();
        switch(layout){
            case 'column':
                geometry = piece.basicBlock(p.z);
                break;
        }
        var color = 'red';
        switch(nature){
            case 'block':
                color = 'white';
                break;
            case 'slope':
                    switch(type){
                        case 1:
//                            piece.simpleSlope(0);
                            break;
                        case 2:
//                            piece.simpleSlope(1);
                            break;
                        case 5:
//                            piece.convexSlope1(0);
                            break;
                        case 6:
//                            piece.concaveSlope1(0);
                            break;
                        case 7:
//                            piece.concaveSlope2(0);
                            break;

                    }
                    console.log("TYPE:", type);
                    if (type <= 2){
//                        piece.simpleSlope(type);
                    } else if (type <= 4){
                    } else if (type <= 6){
//                        piece.concaveSlope1(1);
                    } else {
//                        piece.concaveSlope2(1);
                    }
                    color = 'white';
                break;
            case 'arrow':
                color = 'green';
                break;
            case 'trampoline':
                color = 'yellow';
                break;
            case 'water':
                color = 'blue';
//                piece.addZ(-1);
                break;
        }
        var darkMaterial = new THREE.MeshBasicMaterial( { color: color } );
       	var wireframeMaterial = new THREE.MeshBasicMaterial( { color: 0x000000, wireframe: true, transparent: true } );
       	var multiMaterial = [ darkMaterial, wireframeMaterial ];
        var boxMesh = THREE.SceneUtils.createMultiMaterialObject(geometry, multiMaterial);
        boxMesh.translateX(p.x - 3.5);
        boxMesh.translateY(3.5 - p.y);
        boxMesh.translateZ(p.z / 2);
        boxMesh.rotateZ(-(r % 4) * Math.PI / 2);
        scene.add(boxMesh);
    }

    var i = 64, j = 64, player;
    var assetLoader = new AssetLoader(function(assets) {
        "use strict";
        player = new Player(assets['brushes'].asset, assets['screens'].asset);
        update();
    });
    assetLoader.add('brushes', 'binary', 'assets/models/spindizzy_brushes.bin');
    assetLoader.add('screens', 'binary', 'assets/models/spindizzy_screens.bin');
    assetLoader.load();


    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var orbitControls = new THREE.OrbitControls(camera);

    var canvas = document.getElementById('canvas');
    var renderer = new THREE.WebGLRenderer({ antialias: true, canvas: canvas });
    renderer.setSize(canvas.clientWidth, canvas.clientHeight);


    camera.position.z = 10;

    var scene = new THREE.Scene();

    document.onkeypress = function(evt) {
        evt = evt || window.event;
        var charCode = evt.keyCode || evt.which;
        var charStr = String.fromCharCode(charCode);
        switch(charStr){
            case 'q':
                i = (i - 1) & 0x7F;
                break;
            case 'd':
                i = (i + 1) & 0x7F;
                break;
            case 'z':
                j = (j - 1) & 0x7F;
                break;
            case 's':
                j = (j + 1) & 0x7F;
                break;
        }
        update();
    };

    function update(){
        scene = new THREE.Scene();
        var plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(8, 8, 8, 8), new THREE.MeshBasicMaterial({ wireframe: false, color: 'lightgray', transparent: true, opacity: 0.8 }));
//        scene.add(plane);
        player.screen(paint, new THREE.Vector2(i, j), 0);
        document.getElementById('screenPosition').innerHTML = 'screen: ' + i + ',' + j; // problem at 61,56
        requestAnimationFrame(animate);
    }

    var animate = function (){
        "use strict";
        orbitControls.update();
        requestAnimationFrame(animate);
        renderer.render(scene, camera);
    };

</script>

</body>
</html>