<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/AssetLoader.js"></script>
<script>
    function Player(brushData, screenData){
        this.brushes = {};
        this.screens = {};
        this.methods = ['basic', 'extruded', 'basic', 'column', 'special'];
        this.i0 = 0;
        this.j0 = 0;
        var brushCount = 0, screenCount = 0, offset, l, i, j;
        offset = 0;
        while (offset < brushData.length){
            l = brushData[offset + 1];
            this.brushes[brushData[offset]] = brushData.slice(offset, offset + l);
            offset += l;
            brushCount++;
        }
        console.log('brush count:', brushCount);
        offset = 0;
        while (offset < screenData.length){
            l = screenData[offset];
            j = screenData[offset + 1];
            i = screenData[offset + 2];
            if ((i & 0x80) !== 0){
                i -= 0x80;
                this.i0 = i;
                this.j0 = j;
            }
            this.screens[(j << 8) + i] = screenData.slice(offset, offset + l);
            offset += l;
            screenCount++;
        }
        console.log('screen count:', screenCount);
    }

    Player.prototype.brush = function(level, paint, x, y, z, r, index){
        console.log(level,'> brush:', index);
        var brush = this.brushes[index], offset;
        if (brush){
            offset = 2;
            while (offset < brush.length - 2){
                offset += this.terrain(level, paint, x, y, z, r, brush, offset);
            }
        }
        console.log(level, '> end brush:', index);
    };

    Player.prototype.screen = function(level, paint, i, j){
        console.log(level, '> screen:', i, j);
        var screen = this.screens[(j << 8) + i], offset;
        if (screen) {
            var l = screen[4] + screen[5] << 8;
            var z = l >> 7 & 7, x = l >> 10 & 7, y = l >> 13 & 7;
            // TODO process floor, using x and y
            offset = 6;
            while (!(screen[offset] == 0 && screen[offset + 1] == 0)){
                offset += this.terrain(level, paint, 0, 0, 0, 0, screen, offset);
            }
            offset += 2;
            while(offset < screen.length - 2){
                offset += this.special(level, paint, 0, 0, 0, 0, screen, offset);
            }
            console.log(level, '> end screen:', i, j);
            return true;
        }
        return false;
    };

    Player.prototype.special = function(level, paint, xo, yo, zo, ro, buffer, offset){
        var l = buffer[offset] + (buffer[offset + 1] << 8) + (buffer[offset + 2] << 16);
        var z = l >> 7 & 7, x = l >> 10 & 7, y = l >> 13 & 7;
        var nature = 'undefined';
        if ((l & 0x7F) === 1){
            nature = 'jewel';
        } else if ((l & 0x7) === 2){
            nature = 'lift';
        } else if ((l & 0x77) === 3){
            nature = 'enemy';
        } else if ((l & 4) === 4){
            nature = 'puzzle';
        }
        paint(this.methods[4], xo + x, yo + y, zo + z, ro, nature, l);
        return 3;
    };

    Player.prototype.terrain = function(level, paint, xo, yo, zo, ro, buffer, offset){
        var l = buffer[offset] + (buffer[offset + 1] << 8);
        var z = l >> 7 & 7, x = l >> 10 & 7, y = l >> 13 & 7;
        if ((l & 0x1F) === 2){ // brush reference
            this.brush(level + 1, paint, xo + x, yo + y, zo + z, l & 3, buffer[offset + 2]);
            return 3;
        }
        var f = l & 0x7F, m = f >> 5, t = f >> 2 & 7, r = l & 0x3, nature = 'undefined', type = 0;
        switch(f){
            case 1:
            case 0x21:
            case 0x61:
                nature = 'square';
                break;
            case 3:
            case 0x23:
            case 0x63:
                nature = 'trampoline';
                break;
            case 0x20:
                nature = 'water';
                break;
            case 0x43:
                nature = 'ice';
                break;
            default:
                if ((f & 0x50) === 0x50){
                    nature = 'clue';
                    type = f & 0xF;
                } else if ((f & 0x44) === 0x44){
                    nature = 'arrow';
                } else {
                    nature = 'block';
                    type = t;
                }
                break;
        }
        paint(this.methods[m], xo + x, yo + y, zo + z, (ro + r) & 3, nature, type);
        return 2;
    };

    function paint(method, x, y, z, r, nature, type){
        console.log(method,'(', x, ',',  y, ',', z, ')', r, nature, type);
    }

    var assetLoader = new AssetLoader(function(assets) {
        var player = new Player(assets['brushes'].asset, assets['screens'].asset);
        player.screen(0, paint, player.i0, player.j0);
/*
        var x, y, ar;
        for (y = 40; y < 80; y++){
            if (y % 10 == 0){
                console.log("-");
            }
            ar = [];
            for (x = 40; x < 90; x++) {
                if (x % 10 == 0) {
                    ar.push(" ");
                }
                if (player.screen(paint, x, y)) {
                    ar.push("*");
                } else {
                    ar.push(".");
                }
            }
            console.log(ar.join(""));
        }
*/
    });
    assetLoader.add('brushes', 'binary', 'assets/models/spindizzy_brushes.bin');
    assetLoader.add('screens', 'binary', 'assets/models/spindizzy_screens.bin');
    assetLoader.load();

    var scene = new THREE.Scene();
    var plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(8, 8, 8, 8), new THREE.MeshBasicMaterial({ wireframe: true }));
    scene.add(plane);

    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var orbitControls = new THREE.OrbitControls(camera);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var geometry = new THREE.BoxGeometry(1, 1, 1);
    var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    var cube = new THREE.Mesh(geometry, material);
//    scene.add(cube);

    camera.position.z = 10;

    var animate = function (){
        orbitControls.update();
        requestAnimationFrame(animate);
        cube.rotation.x += 0.1;
        cube.rotation.y += 0.1;
        renderer.render(scene, camera);
    };

</script>



</body>
</html>