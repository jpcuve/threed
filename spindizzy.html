<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        body {
            margin: 0;
        }

        canvas {
            width: 100%;
            height: 100%;
        }
    </style>
</head>
<body>
<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/AssetLoader.js"></script>
<script>
    function Player(brushData, screenData){
        this.brushes = {};
        this.screens = {};
        this.methods = ['basic', 'extruded', 'clue', 'column', 'special'];
        var brushCount = 0, screenCount = 0, offset, l, i, j;
        offset = 0;
        while (offset < brushData.length){
            l = brushData[offset + 1];
            this.brushes[brushData[offset]] = brushData.slice(offset, offset + l);
            offset += l;
            brushCount++;
        }
        console.log('brush count:', brushCount);
        offset = 0;
        while (offset < screenData.length){
            l = screenData[offset];
            j = screenData[offset + 1];
            i = screenData[offset + 2];
            this.screens[(j << 8) + i] = screenData.slice(offset, offset + l);
            offset += l;
            screenCount++;
        }
        console.log('screen count:', screenCount);
    }

    Player.prototype.brush = function(paint, x, y, z, r, index){
//        console.log('brush:', index);
        var brush = this.brushes[index], offset;
        if (brush){
            offset = 2;
            while (offset < brush.length){
                offset += this.terrain(paint, x, y, z, r, brush, offset);
            }
        }
    };

    Player.prototype.screen = function(paint, i, j){
//        console.log('screen:', i, j);
        var screen = this.screens[(j << 8) + i], offset;
        if (screen) {
            // TODO process floor
            var l = screen[4] + screen[5] << 8;
            var z = l >> 7 & 7, x = l >> 10 & 7, y = l >> 13 & 7;
/*
            while (x < 8){
                while (y < 8){
                    y++;


                }
                x++;
            }
*/

            offset = 6;
            while (screen[offset] != 0){
                offset += this.terrain(paint, 0, 0, 0, 0, screen, offset);
            }
            offset += 2;
            while(screen[offset] != 0){
                offset += this.special(paint, 0, 0, 0, 0, screen, offset);
            }
            return true;
        }
        return false;
    };

    Player.prototype.special = function(paint, xo, yo, zo, ro, buffer, offset){
        var l = buffer[offset] + (buffer[offset + 1] << 8) + (buffer[offset + 2] << 16);
        var z = l >> 7 & 7, x = l >> 10 & 7, y = l >> 13 & 7;
        var nature = 'undefined';
        if ((l & 0x7F) === 1){
            nature = 'jewel';
        } else if ((l & 0x7) === 2){
            nature = 'lift';
        } else if ((l & 0x77) === 3){
            nature = 'enemy';
        } else if ((l & 4) === 4){
            nature = 'puzzle';
        }
        paint(this.methods[4], xo + x, yo + y, zo + z, ro, nature, l);
        return 3;
    };

    Player.prototype.terrain = function(paint, xo, yo, zo, ro, buffer, offset){
        var l = buffer[offset] + (buffer[offset + 1] << 8);
        var z = l >> 7 & 7, x = l >> 10 & 7, y = l >> 13 & 7;
        if ((l & 0x1F) === 2){ // brush reference
            this.brush(paint, x, y, z, l & 3, buffer[offset + 2]);
            return 3;
        }
        var m = l && 0x7F, nature, type = 0, r = 0;
        switch(m){
            case 1:
                nature = 'square';
                break;
            case 3:
                nature = 'trampoline';
                break;
            case 0x40:
                nature = 'water';
                break;
            case 0x43:
                nature = 'ice';
                break;
            default:
                if (m > 0x20){
                    if (m & 0x20){
                        nature = 'arrow';
                        r = m & 3;
                    } else {
                        nature = 'clue';
                        type = m & 0xF;
                        r = 0;
                    }
                } else {
                    nature = 'block';
                    type = m >> 2 & 7;
                    r = m & 3;
                }
                break;
        }
        paint(this.methods[(m >> 5) & 3], xo + x, yo + y, zo + z, (ro + r) & 3, nature, type);
        return 2;
    };

    function paint(method, x, y, z, r, nature, type){
//        console.log(method, x, y, z, r, nature, type);
    }

    var assetLoader = new AssetLoader(function(assets) {
        var player = new Player(assets['brushes'].asset, assets['screens'].asset);
        player.screen(paint, 58, 69);
        var x, y, ar;
        for (y = 0; y < 128; y++){
            ar = [];
            for (x = 0; x < 128; x++){
                if (player.screen(paint, x, y)){
                    ar.push("*");
                } else {
                    ar.push(".");
                }
            }
            console.log(ar.join(""));
        }
    });
    assetLoader.add('brushes', 'binary', 'assets/models/spindizzy_brushes.bin');
    assetLoader.add('screens', 'binary', 'assets/models/spindizzy_screens.bin');
    assetLoader.load();

    var scene = new THREE.Scene();
    var plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(8, 8, 8, 8), new THREE.MeshBasicMaterial({ wireframe: true }));
    scene.add(plane);

    var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    var orbitControls = new THREE.OrbitControls(camera);

    var renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    var geometry = new THREE.BoxGeometry(1, 1, 1);
    var material = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    var cube = new THREE.Mesh(geometry, material);
//    scene.add(cube);

    camera.position.z = 10;

    var animate = function (){
        orbitControls.update();
        requestAnimationFrame(animate);
        cube.rotation.x += 0.1;
        cube.rotation.y += 0.1;
        renderer.render(scene, camera);
    };

</script>



</body>
</html>